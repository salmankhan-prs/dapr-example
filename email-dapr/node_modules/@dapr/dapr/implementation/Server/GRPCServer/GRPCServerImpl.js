"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const any_pb_1 = require("google-protobuf/google/protobuf/any_pb");
const common_pb_1 = require("../../../proto/dapr/proto/common/v1/common_pb");
const appcallback_pb_1 = require("../../../proto/dapr/proto/runtime/v1/appcallback_pb");
const HttpVerbUtil = __importStar(require("../../../utils/HttpVerb.util"));
const Logger_1 = require("../../../logger/Logger");
// https://github.com/badsyntax/grpc-js-typescript/issues/1#issuecomment-705419742
// @ts-ignore
class GRPCServerImpl {
    constructor(loggerOptions) {
        this.logger = new Logger_1.Logger("GRPCServer", "GRPCServerImpl", loggerOptions);
        this.handlersInvoke = {};
        this.handlersBindings = {};
        this.handlersTopics = {};
    }
    createPubSubSubscriptionHandlerKey(pubSubName, topicName) {
        return `${pubSubName.toLowerCase()}|${topicName.toLowerCase()}`;
    }
    createInputBindingHandlerKey(bindingName) {
        return `${bindingName.toLowerCase()}`;
    }
    createOnInvokeHandlerKey(httpMethod, methodName) {
        return `${httpMethod.toLowerCase()}|${methodName.toLowerCase()}`;
    }
    registerOnInvokeHandler(httpMethod, methodName, cb) {
        const handlerKey = this.createOnInvokeHandlerKey(httpMethod, methodName);
        this.handlersInvoke[handlerKey] = cb;
    }
    registerPubSubSubscriptionHandler(pubSubName, topicName, cb) {
        const handlerKey = this.createPubSubSubscriptionHandlerKey(pubSubName, topicName);
        this.handlersTopics[handlerKey] = cb;
    }
    registerInputBindingHandler(bindingName, cb) {
        const handlerKey = this.createInputBindingHandlerKey(bindingName);
        this.handlersBindings[handlerKey] = cb;
    }
    // '(call: ServerUnaryCall<InvokeRequest, InvokeResponse>, callback: sendUnaryData<InvokeResponse>) => Promise<...>'
    // handleUnaryCall<InvokeRequest, InvokeResponse>'.
    onInvoke(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = call.request.getMethod();
            const query = call.request.getHttpExtension().toObject();
            const methodStr = HttpVerbUtil.convertHttpVerbNumberToString(query.verb);
            const handlersInvokeKey = `${methodStr.toLowerCase()}|${method.toLowerCase()}`;
            if (!this.handlersInvoke[handlersInvokeKey]) {
                this.logger.warn(`${methodStr} /${method} was not handled`);
                return;
            }
            const body = Buffer.from(call.request.getData().getValue()).toString();
            const contentType = call.request.getContentType();
            // Invoke the Method Callback
            // @TODO add call.metadata, it has headers of original HTTP request.
            const invokeResponseData = yield this.handlersInvoke[handlersInvokeKey]({
                body,
                query: query.querystring,
                metadata: {
                    contentType
                }
            });
            // Generate Response
            const res = new common_pb_1.InvokeResponse();
            res.setContentType("application/json");
            if (invokeResponseData) {
                const msgSerialized = new any_pb_1.Any();
                msgSerialized.setValue(Buffer.from(JSON.stringify(invokeResponseData), "utf-8"));
                res.setData(msgSerialized);
            }
            // @TODO add Error Handleling, for ex if service returned error with status code
            // also maybe we can map GRPC error codes in a enum
            return callback(null, res);
        });
    }
    // @todo: WIP
    onBindingEvent(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = call.request;
            const handlerKey = this.createInputBindingHandlerKey(req.getName());
            if (!this.handlersBindings[handlerKey]) {
                this.logger.warn(`Event for binding: "${handlerKey}" was not handled`);
                return;
            }
            const data = Buffer.from(req.getData()).toString();
            let dataParsed;
            try {
                dataParsed = JSON.parse(data);
            }
            catch (e) {
                dataParsed = data;
            }
            yield this.handlersBindings[handlerKey](dataParsed);
            // @todo: we should add the state store or output binding binding
            // see: https://docs.dapr.io/reference/api/bindings_api/#binding-endpoints
            const res = new appcallback_pb_1.BindingEventResponse();
            return callback(null, res);
        });
    }
    // @todo: WIP
    onTopicEvent(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = call.request;
            const handlerKey = this.createPubSubSubscriptionHandlerKey(req.getPubsubName(), req.getTopic());
            if (!this.handlersTopics[handlerKey]) {
                this.logger.warn(`Event from topic: "${handlerKey}" was not handled`);
                return;
            }
            const data = Buffer.from(req.getData()).toString();
            let dataParsed;
            try {
                dataParsed = JSON.parse(data);
            }
            catch (e) {
                dataParsed = data;
            }
            const res = new appcallback_pb_1.TopicEventResponse();
            try {
                yield this.handlersTopics[handlerKey](dataParsed);
                res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.SUCCESS);
            }
            catch (e) {
                // @todo: for now we drop, maybe we should allow retrying as well more easily?
                this.logger.error(`Error handling topic event: ${e}`);
                res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.DROP);
            }
            return callback(null, res);
        });
    }
    // @todo: WIP
    listTopicSubscriptions(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = new appcallback_pb_1.ListTopicSubscriptionsResponse();
            const values = Object.keys(this.handlersTopics).map((i) => {
                const handlerTopic = i.split("|");
                const topicSubscription = new appcallback_pb_1.TopicSubscription();
                topicSubscription.setPubsubName(handlerTopic[0]);
                topicSubscription.setTopic(handlerTopic[1]);
                return topicSubscription;
            });
            res.setSubscriptionsList(values);
            return callback(null, res);
        });
    }
    // @todo: WIP
    listInputBindings(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = new appcallback_pb_1.ListInputBindingsResponse();
            res.setBindingsList(Object.keys(this.handlersBindings));
            return callback(null, res);
        });
    }
}
exports.default = GRPCServerImpl;
